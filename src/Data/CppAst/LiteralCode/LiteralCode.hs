{-# LANGUAGE DeriveFoldable    #-}
{-# LANGUAGE DeriveFunctor     #-}
{-# LANGUAGE DeriveGeneric     #-}
{-# LANGUAGE DeriveTraversable #-}

module Data.CppAst.LiteralCode.LiteralCode
  ( LiteralCode(..)
  , CString
  , Index
  , Id
  , UNamePart
  ) where

import           Data.Bifunctor
import           Data.CppAst.LiteralCode.HasUniqueNames
import           Data.CppAst.LiteralCode.Utils
import           Data.Maybe
import           Data.String

-- | A name that should be iserted in a string. Global defs is the
-- code of the definition and the code of the symbol/expression
-- generated by that definition. The generated symbol's unique name
-- ids will follow these of the generated definition so that they are
-- insertible in the main body.
type CString = String
type Index = Int
type Id = Int
type UNamePart = (Id, Id -> CString)
data LiteralCode = LiteralCode {
  globalDefs      :: [(LiteralCode, UNamePart)],
  hardUNames      :: [(Index, Id, Id -> CString)],
  nextHardId      :: Id,
  fromLiteralCode :: CString}
instance IsString LiteralCode where fromString s = mempty{fromLiteralCode=s}
instance Monoid LiteralCode where
  mempty = LiteralCode mempty mempty 0 mempty
instance Semigroup LiteralCode where
  x <> y = unsafeAppend x $ mapOverIds (+ nextHardId x) y where
    -- Concat considering the hard ids unique.
    unsafeAppend (LiteralCode gd hn _ lc) (LiteralCode gd' hn' mhi' lc') =
      LiteralCode
      (gd <> gd')
      (hn <> (rebaseUNameIndex <$> hn'))
      mhi'
      (lc <> lc')
      where
        rebaseUNameIndex (a, b, c) = (a + length lc, b, c)

instance Eq LiteralCode where
  a == b = equalWithEnv [] ([], a) ([], b)
-- | An check equality of LiteralCode objects in given a global
-- definitions context. The first alement of the tuples is a list of
-- global definition Ids to ignore in order to avoid recursion.
equalWithEnv :: [(LiteralCode, UNamePart)]
             -> ([Id], LiteralCode) -> ([Id], LiteralCode)
             -> Bool
equalWithEnv env' = go env' env' where
  go envA envB  (skipIdsA, a) (skipIdsB, b) =
    fromLiteralCode a == fromLiteralCode b &&
    and (zipWith (structureEqual envA' envB')
          (unameStructure envA' skipIdsA a)
          (unameStructure envB' skipIdsB b))
    where
      envA' = globalDefs a ++ envA
      envB' = globalDefs b ++ envB
      structureEqual :: [(LiteralCode, UNamePart)]
                     -> [(LiteralCode, UNamePart)]
                     -> (Maybe ([Id], LiteralCode), [Index])
                     -> (Maybe ([Id], LiteralCode), [Index])
                     -> Bool
      structureEqual lenv renv (gdefa, structa) (gdefb, structb) =
        structa == structb &&
        (go lenv renv <$> gdefa <*> gdefb) /= Just False
      -- The structure of corresponding names:
      -- [(Maybe (Ids, GlobalDef), [Index])]
      unameStructure env skipIds x = first lookupGDef <$> hyperGraph idsOfX
        where
          idsOfX = snd3 <$> hardUNames x where
            snd3 (_, x', _) = x'
          lookupGDef i' = listToMaybe $ (\(g, (i, _)) -> (i:skipIds, g))
            <$> filter (\(_, (i, _)) -> (i' == i) && i `notElem` skipIds) env

instance HasUniqueNames LiteralCode where
  maxNameIndex = length . fromLiteralCode
-- | Apply function recursively to all Ids in the code.
mapOverIds :: (Id -> Id) -> LiteralCode -> LiteralCode
mapOverIds f lc = lc{
  globalDefs=(mapOverIds f `bimap` first f) <$> globalDefs lc,
  hardUNames=second3 f <$> hardUNames lc,
  nextHardId=f $ nextHardId lc}
  where
    second3 g (a, b, c) = (a, g b, c)
